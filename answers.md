### 1. Как вы можете описать процесс распространения событий в JavaScript (Event Propagation)? Расскажите о его основных фазах. Какие есть способы применения знаний о фазах распространения событий на практике?

Механизм распространения событий — это способ, с помощью которого браузер определяет порядок, в котором должны выполняться события при клике или взаимодействии с каким-либо элементом на странице. Когда пользователь нажимает на элемент внутри дерева DOM, это взаимодействие влияет не только на сам элемент, но и на его родительские элементы, вплоть до корня документа. То есть одно событие может затронуть сразу несколько уровней элементов одновременно.

Существует три основных этапа распространения событий:

Первый этап — это **этап захвата**, когда событие начинается с самого верха дерева, с корневого узла документа, а затем постепенно “спускается” вниз, проходя через все элементы на своём пути до того элемента, с которым произошло взаимодействие.

Затем наступает **этап цели**, в этот момент событие обрабатывается непосредственно на элементе, с которым произошло взаимодействие, например при клике.

После этого начинается **этап всплытия**, когда событие снова “поднимается” вверх, проходя через те же элементы, но уже в обратном порядке — от целевого элемента к корню. В большинстве случаев обработчики событий выполняются именно на этом этапе.

Теперь что касается применения этих знаний на практике. Иногда требуется, чтобы событие обрабатывалось только на одном элементе и не распространялось дальше. Например, если вы нажали на дочерний элемент, но не хотите, чтобы событие передавалось родительскому, можно остановить распространение события с помощью метода `event.stopPropagation()`. Вот как это выглядит на практике:

```javascript
document.getElementById('child').addEventListener('click', (event) => {
  event.stopPropagation();
  console.log('');
});
```

Бывают и противоположные ситуации — когда нужно обработать событие во время фазы захвата, то есть когда оно движется сверху вниз от корня к целевому элементу, а не во время всплытия. Для этого можно передать третий параметр `true` в метод `addEventListener`, и тогда обработчик сработает именно на этапе захвата, как показано ниже:

```javascript
document.getElementById('grandparent').addEventListener(
  'click',
  () => {
    console.log('');
  },
  true
);
```

По умолчанию, если этот параметр не указан, `addEventListener` работает на этапе всплытия — после того, как событие поднимается от целевого элемента к корню. Но если добавить значение `true`, событие будет перехвачено во время движения вниз, ещё до того, как достигнет целевого элемента.

Существует также другая интересная техника, связанная с этим механизмом, — **делегирование событий**. Эта техника основана на фазе всплытия и используется для уменьшения количества обработчиков событий на странице. Например, если у нас есть список с десятками элементов, добавление отдельного обработчика к каждому из них будет неэффективным. Вместо этого можно добавить один обработчик на родительский элемент и внутри проверить, на каком именно элементе произошло событие. Ниже приведён пример:

```javascript
document.querySelector('#list').addEventListener('click', (event) => {
  if (event.target.tagName === 'LI') {
    console.log();
  }
});
```

Таким образом, обработчик “улавливает” клики по всем дочерним элементам, но выполняет код только тогда, когда событие произошло на нужном элементе. Такой подход делает код проще и эффективнее, особенно когда на странице много элементов.

---

### 2. Расскажите, что такое Promise в JavaScript, как он работает, какие основные состояния у него бывают? Каким еще способом можно обработать асинхронный код? Какую роль в асинхронности играет событийный цикл (Event Loop)?

Это объект, который представляет собой «обещанный результат» операции, которая может завершиться позже — успешно или с ошибкой. Иными словами, это своего рода обещание, что результат появится в будущем, нужно лишь подождать.

При создании нового объекта типа `Promise` мы передаём в него функцию, называемую **функцией-исполнителем** (executor function).  
Эта функция принимает два аргумента — `resolve` и `reject`.  
Аргумент `resolve` вызывается, когда операция завершается успешно,  
а `reject` — если происходит ошибка или сбой в процессе выполнения.

После этого мы можем работать с результатом, используя методы `.then()`, `.catch()` и `.finally()`.  
Метод `.then()` используется при успешном выполнении операции,  
`.catch()` — при возникновении ошибки,  
а `.finally()` выполняется всегда, независимо от результата.  
Обычно его применяют для выполнения завершающих действий,  
например очистки данных или скрытия индикатора загрузки.

`Promise` проходит через три основных состояния:  
Сначала он находится в состоянии **ожидания (Pending)** — это значит, что операция ещё выполняется и результат пока неизвестен.  
Когда операция завершается успешно и вызывается `resolve`, `Promise` переходит в состояние **выполнен (Fulfilled)**.  
Если же происходит ошибка и вызывается `reject`, он переходит в состояние **отклонён (Rejected)**.

В JavaScript также существует современный и более удобный способ работы с асинхронным кодом — использование ключевых слов `async` и `await`.  
Если добавить слово `async` перед определением функции, она становится **асинхронной** и автоматически возвращает объект `Promise`.  
Ключевое слово `await`, которое можно использовать только внутри асинхронных функций,  
«приостанавливает» выполнение кода до тех пор, пока `Promise` не завершится,  
а затем возвращает его результат.  
Таким образом, код выглядит как синхронный, хотя на самом деле остаётся асинхронным.

В следующем примере можно увидеть, как это работает на практике:

```javascript
async function getData() {
  try {
    const response = await fetch('https://api.com/');
    const data = await response.json();
    console.log(data);
  } catch (error) {
    console.error(error);
  }
}
```

В этом примере функция `getData` отправляет запрос на сервер.  
Сначала она ожидает ответ с помощью `await fetch`,  
затем ждёт преобразования результата в формат JSON,  
и после этого выводит данные в консоль.  
Если во время выполнения произойдёт ошибка — например, сервер не ответит, —  
управление сразу перейдёт в блок `catch`, где ошибка будет обработана.

Роль Event Loop: в целом, **цикл событий (Event Loop)** отвечает за управление выполнением синхронного и асинхронного кода таким образом,  
чтобы программа не “замерзала” во время работы.

Когда программа выполняется и встречает асинхронную задачу,  
эта задача передаётся в **Web APIs**, где выполняется в фоновом режиме.  
После завершения её результат помещается в **очередь задач (Task Queue)**.  
Далее **Event Loop** следит за состоянием **стека вызовов (Call Stack)**,  
и как только он становится пустым, цикл событий переносит задачу из очереди в стек,  
чтобы выполнить её в нужный момент.

Благодаря этому механизм позволяет JavaScript оставаться однопоточным,  
но при этом эффективно обрабатывать множество операций одновременно —  
например, сетевые запросы, таймеры и события пользовательского интерфейса —  
без блокировки основного потока выполнения программы.

---

### 3. Что такое ООП, и какие его ключевые принципы вы могли бы описать? При объяснении приводите примеры. Максимально подробно расскажите о том, как ООП реализовано в JavaScript.

Это стиль программирования, основанный на идее **разделения кода на объекты (Objects)**.  
Каждый объект представляет собой небольшую сущность, у которой есть собственные данные — называемые **свойствами (Properties)**,  
и функции, которые работают с этими данными — называемые **методами (Methods)**.  
Такой подход делает код более организованным, понятным и простым в использовании,  
а также более пригодным для повторного использования.

Существует четыре основных принципа, о которых я расскажу далее с примерами:
**Первый принцип — инкапсуляция (Encapsulation).**  
Её суть заключается в объединении данных и функций, работающих с ними, внутри одного объекта,  
при этом ограничивается прямой доступ к этим данным извне.  
Это означает, что никакая часть кода не может изменить внутренние значения, если мы этого не предусмотрели.  
Управление данными осуществляется только через специальные методы, называемые **Getters** и **Setters**.

В JavaScript это можно реализовать с помощью **приватных полей**, обозначаемых символом `#`,  
а также с помощью методов Getter и Setter, которые позволяют безопасно получать и изменять значения.
В следующем примере свойство `#speed` защищено внутри класса,  
и к нему нельзя обратиться напрямую снаружи:

```javascript
class Vehicle {
  #speed = 0;

  constructor(brand) {
    this.brand = brand;
  }

  accelerate(amount) {
    this.#speed += amount;
    console.log(`${this.brand} ускоряется до ${this.#speed} км/ч`);
  }

  brake() {
    this.#speed = Math.max(0, this.#speed - 10);
    console.log(`${this.brand} замедляется до ${this.#speed} км/ч`);
  }

  get speed() {
    return this.#speed;
  }
}
```

**Второй принцип — абстракция (Abstraction).**  
Её цель — **скрыть сложные внутренние детали объекта**  
и показать пользователю только то, что действительно необходимо для взаимодействия с ним.  
Это делает код проще, понятнее и удобнее для сопровождения.

В JavaScript абстракцию можно реализовать с помощью **базового класса (Base Class)**,  
который содержит общие интерфейсы, но не реализует их напрямую.  
Также можно использовать `throw Error`, чтобы заставить дочерние классы реализовать необходимые методы.

В следующем примере класс `Vehicle` представляет общее понятие транспортного средства,  
но сам по себе он не используется, потому что требует от дочерних классов реализации метода `startEngine()`.  
По сути, он ведёт себя как абстрактный класс:

```javascript
class Vehicle {
  startEngine() {
    throw new Error('Метод startEngine() должен быть реализован в дочернем классе');
  }
}
```

**Третий принцип — наследование (Inheritance).**  
Этот механизм позволяет создавать новый класс на основе существующего,  
чтобы переиспользовать его свойства и методы без дублирования кода.  
Таким образом, код становится проще и легче расширяется.

В JavaScript наследование реализуется с помощью ключевого слова `extends`,  
которое связывает дочерний класс с родительским,  
и вызова `super()`, с помощью которого можно обратиться к методам или конструктору родителя.

В следующем примере классы `Car` и `Motorcycle` наследуются от `Vehicle`  
и переопределяют метод `startEngine()` по-своему, в зависимости от типа транспорта:

```javascript
class Car extends Vehicle {
  constructor(brand, model) {
    super(brand);
    this.model = model;
  }

  startEngine() {
    console.log(`${this.brand} ${this.model}: запуск двигателя автомобиля`);
  }
}

class Motorcycle extends Vehicle {
  constructor(brand, type) {
    super(brand);
    this.type = type;
  }

  startEngine() {
    console.log(`${this.brand} (${this.type}): запуск двигателя мотоцикла`);
  }
}
```

**Четвёртый принцип — полиморфизм (Polymorphism).**  
Он означает, что одна и та же функция может вести себя по-разному  
в зависимости от того, какой объект её вызывает.  
Иными словами, метод имеет одно имя, но разную реализацию в каждом классе.

В JavaScript это достигается с помощью **переопределения методов (Overriding)** в дочерних классах.  
Мы можем вызывать один и тот же метод для разных объектов,  
и каждый из них выполнит его по-своему.

В следующем примере метод `startEngine()` вызывается для разных объектов,  
и результат зависит от типа объекта:

```javascript
function startAllEngines(vehicles) {
  vehicles.forEach((vehicle) => {
    vehicle.startEngine();
  });
}

const car = new Car('Toyota', 'Corolla');
const bike = new Motorcycle('Yamaha', 'Sport');

startAllEngines([car, bike]);
```

**Результат будет таким:**

```
Toyota Corolla: запуск двигателя автомобиля
Yamaha (Sport): запуск двигателя мотоцикла
```

Таким образом, мы видим, что принцип **полиморфизма** позволяет использовать один и тот же метод  
для объектов с разным поведением, делая код более гибким и структурированным.

---

### 4. Опишите максимально детально, как браузер обрабатывает URL, начиная с момента его ввода в адресную строку и заканчивая отображением страницы. Какие технологии позволяют ускорить процесс? Какие проблемы (безопасность, междоменное взаимодействие) могут возникать в процессе?

Например, у нас есть следующая ссылка: [https://random.com/users?id=5](https://random.com/users?id=5)

Сначала, когда пользователь вводит адрес в браузере, браузер анализирует ссылку и делит её на несколько частей: протокол https, доменное имя random.com, путь /users и параметр запроса id=5. Затем браузер проверяет, сохранён ли этот домен в его кэше. Если нет, он обращается к серверу DNS, который отвечает за преобразование доменного имени в соответствующий IP-адрес сервера. IP-адрес необходим, потому что соединение между устройствами в сети осуществляется именно по нему, тогда как доменное имя предназначено для удобства пользователей, так как его проще запомнить и ввести.

После того как браузер получает IP-адрес от DNS-сервера, он устанавливает соединение TCP с сервером. Если соединение осуществляется через протокол https, поверх него создаётся слой безопасности TLS, который шифрует данные и защищает их при передаче. Затем браузер отправляет HTTP-запрос, содержащий тип запроса, например GET, а также дополнительную информацию, такую как тип браузера и куки. Сервер принимает запрос, обрабатывает его и отправляет ответ обратно браузеру. Ответ включает код состояния, например 200 при успешном выполнении, 301 при перенаправлении или 404, если страница не найдена, а также заголовки (Headers) и содержимое страницы.

После этого браузер начинает считывать и анализировать файл HTML, полученный от сервера. В процессе анализа он может обнаружить ссылки на файлы CSS, JavaScript или изображения и начинает загружать их. Из HTML-файла браузер строит дерево DOM, из файлов CSS — дерево CSSOM, затем объединяет их в дерево визуализации (Render Tree), которое определяет, как элементы будут отображаться на странице. После этого выполняется этап расчёта расположения элементов (Layout), затем их отрисовка на экране (Painting), и начинается выполнение JavaScript-кода, присутствующего на странице.

Чтобы ускорить этот процесс, браузеры и серверы используют различные методы. Например, можно использовать кэш для временного хранения файлов, чтобы не загружать их заново при каждом обращении, применять сжатие (Compression), чтобы уменьшить размер файлов перед отправкой, или использовать CDN — распределённые серверы, расположенные ближе к пользователю, что ускоряет загрузку страниц. Также можно применять технологию «ленивой загрузки» (Lazy Loading), при которой изображения и элементы загружаются только тогда, когда пользователь действительно к ним приближается или запрашивает их.

Во время этого процесса могут возникать разные проблемы, влияющие на производительность и безопасность. Одна из главных — безопасность: если сайт не использует протокол HTTPS, соединение считается небезопасным и данные могут быть перехвачены или изменены. Кроме того, могут возникать проблемы взаимодействия между доменами (CORS), когда скрипт с одного сайта пытается получить доступ к данным другого сайта без разрешения, что запрещено политикой одинакового источника (Same-Origin Policy), если только сервер не разрешает это явно через настройки CORS. Также возможны проблемы с производительностью — например, медленная загрузка из-за большого количества скриптов, тяжёлых CSS-файлов или изображений большого размера, которые замедляют отображение страницы.
